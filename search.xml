<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vimgolf001</title>
    <url>/2020/05/11/vimgolf001/</url>
    <content><![CDATA[<h1 id="vimgolf第一题"><a href="#vimgolf第一题" class="headerlink" title="vimgolf第一题"></a>vimgolf第一题</h1><p>[TOC]<br>目标是10步</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目-"></a>题目-</h2><p>prepend * to every non-blank line<br><a href="http://www.vimgolf.com/challenges/5e4dfcccaa2db400090b66c3" target="_blank" rel="noopener">http://www.vimgolf.com/challenges/5e4dfcccaa2db400090b66c3</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gem install vimgolf</span><br><span class="line">vimgolf <span class="built_in">setup</span></span><br><span class="line">vimgolf <span class="built_in">put</span> <span class="number">5e4</span>dfcccaa2db400090b66c3</span><br></pre></td></tr></table></figure>

<h2 id="Start-file"><a href="#Start-file" class="headerlink" title="Start file"></a>Start file</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Start file</span><br><span class="line"></span><br><span class="line">This is a</span><br><span class="line">very short</span><br><span class="line"></span><br><span class="line">file, but it is</span><br><span class="line">still</span><br><span class="line">full</span><br><span class="line"></span><br><span class="line">of</span><br><span class="line"></span><br><span class="line">surpises.</span><br></pre></td></tr></table></figure>

<h2 id="End-file"><a href="#End-file" class="headerlink" title="End file"></a>End file</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*This is a</span><br><span class="line">*very short</span><br><span class="line"></span><br><span class="line">*file, but it is</span><br><span class="line">*still</span><br><span class="line">*full</span><br><span class="line"></span><br><span class="line">*of</span><br><span class="line"></span><br><span class="line">*surpises.</span><br></pre></td></tr></table></figure>

<h2 id="思路和过程"><a href="#思路和过程" class="headerlink" title="思路和过程"></a>思路和过程</h2><ul>
<li>vim退出</li>
</ul>
<p><strong>vim 保存退出用ZZ<br>或者:wq<br>:q是不保存退出<br>:q!放弃处理结果</strong></p>
<ol>
<li>第一次最差是20,没什么可说的</li>
<li>第二次使用了视图模式ctrl+v然后G到最后,然后I来编辑-18步<br><code>&lt;C-V&gt;GI*&lt;Esc&gt;2jx4jx2jx:wq&lt;CR&gt;</code></li>
<li><code>&lt;C-V&gt;GI*&lt;Esc&gt;3Gx7G.9G.ZZ</code> 16步骤</li>
<li><code>:%s/^\ze\w/*&lt;CR&gt;ZZ</code> - 15步</li>
<li><code>:%s/^\ze./*&lt;CR&gt;ZZ</code> - 14</li>
<li>:<code>%s/^./*&amp;/&lt;CR&gt;ZZ</code> - 13</li>
<li><code>:%s/^./*&amp;&lt;CR&gt;ZZ</code> - 12</li>
<li><code>:%s/./*&amp;&lt;CR&gt;ZZ</code> - 11</li>
<li><code>&lt;C-V&gt;GyPgvr*ZZ</code> - 冠军</li>
</ol>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><ol>
<li>第二次使用了视图模式ctrl+v然后G到最后,然后I来编辑-18步<br><code>&lt;C-V&gt;GI*&lt;Esc&gt;2jx4jx2jx:wq&lt;CR&gt;</code></li>
<li><code>&lt;C-V&gt;GI*&lt;Esc&gt;3Gx7G.9G.ZZ</code> 16步骤</li>
<li><code>:%s/^\ze\w/*&lt;CR&gt;ZZ</code> - 15步</li>
<li><code>:%s/^\ze./*&lt;CR&gt;ZZ</code> - 14</li>
<li>:<code>%s/^./*&amp;/&lt;CR&gt;ZZ</code> - 13</li>
<li><code>:%s/^./*&amp;&lt;CR&gt;ZZ</code> - 13</li>
<li><code>:%s/./*&amp;&lt;CR&gt;ZZ</code> - 11</li>
<li><code>&lt;C-V&gt;GyPgvr*ZZ</code> - 冠军 10</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>三种视图模式</p>
<p>字符选择模式　　v</p>
<p>行选择模式　　　shift-v</p>
<p>块选择模式　　　ctrl-v</p>
<p>帮助　　加前缀v_，如 :help v_d</p>
<p>在其中一种模式下可以用直接用上面的命令切换到另一模式</p>
<p>在视图模式下编辑</p>
<p>d　　删除选中的字符　　D　　删除选中字符的行</p>
<p>y，c命令同理</p>
<p>J　　将选中行合成一行，行这间用空格分隔　　gJ　　连接选中行并无空格分隔</p>
<blockquote>
<p>　将选中行缩进一个shiftwidth　　反之 &lt;</p>
</blockquote>
<p>在块选择模式下</p>
<p>I　　插入，并且在<ESC>后，其他选中行的相应位置也会插入相同内容</p>
<p>c，A命令有相类似的作用</p>
<p>r　　将选中块中的字符全部替代为某个字符</p>
<blockquote>
<p>　将块向右移动一个shiftwidth　　反之 &lt;，如果空格数不足一个shiftwidth，它尽可能的移动</p>
</blockquote>
]]></content>
      <categories>
        <category>vim</category>
        <category>vimgolf</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vimgolf</tag>
      </tags>
  </entry>
  <entry>
    <title>vimgolf002</title>
    <url>/2020/05/13/vimgolf002/</url>
    <content><![CDATA[<h2 id="vimgolf002-Simple-Practical-and-Common"><a href="#vimgolf002-Simple-Practical-and-Common" class="headerlink" title="vimgolf002-Simple, Practical, and Common"></a>vimgolf002-Simple, Practical, and Common</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><p>vimgolf put 55b18bbea9c2c30d04000001</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*temp var1 <span class="number">0</span></span><br><span class="line">*temp var2 <span class="string">"hi"</span></span><br><span class="line">*temp var3 <span class="number">-1</span></span><br><span class="line">*temp var4 <span class="number">42</span></span><br><span class="line">*temp var5 <span class="string">"asdf"</span></span><br><span class="line">*temp var6 <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Simple things we <span class="keyword">do</span> all the time should be able to be done with very few keystrokes, but sometimes I <span class="built_in">find</span> something I need to <span class="keyword">do</span> makes me go, <span class="string">"There MUST be a better way."</span></span><br><span class="line"></span><br><span class="line">This challenge is just a simple movement <span class="keyword">and</span> entering <span class="built_in">text</span> at a certain place.</span><br><span class="line">-----</span><br><span class="line">*temp var1 <span class="number">0</span></span><br><span class="line">*temp var2 <span class="string">"hi"</span></span><br><span class="line">*temp var3 <span class="number">-1</span></span><br><span class="line">*temp var4 <span class="number">42</span></span><br><span class="line">*temp var5 <span class="string">"asdf"</span></span><br><span class="line">*temp var6 <span class="number">0</span></span><br><span class="line">*temp var7 <span class="number">11</span></span><br><span class="line"></span><br><span class="line">Simple things we <span class="keyword">do</span> all the time should be able to be done with very few keystrokes, but sometimes I <span class="built_in">find</span> something I need to <span class="keyword">do</span> makes me go, <span class="string">"There MUST be a better way."</span></span><br><span class="line"></span><br><span class="line">New <span class="built_in">text</span>.</span><br><span class="line"></span><br><span class="line">This challenge is just a simple movement <span class="keyword">and</span> entering <span class="built_in">text</span> at a certain place.</span><br></pre></td></tr></table></figure>

<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>最佳答案是22步骤:</p>
<ol>
<li><code>#Yp&lt;C-A&gt;l11.GONew t&lt;C-N&gt;&lt;C-N&gt;.&lt;CR&gt;&lt;Esc&gt;ZZ</code></li>
<li>MYp<C-A>w11.GONew t<C-N><C-N>.<CR><Esc>ZZ</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>‘#’号码是往上找当前的单词,所以倒数走到了最后一个第六行开头</strong></li>
<li>Y是复制一整行是yy的简写</li>
<li><strong>c-a是有用的 数字+1,-1是ctrl-x</strong></li>
<li>然后按一下l,往右走一下,然后11 .来重复</li>
<li>G直接走到最后一行</li>
<li>O在上面新建一行</li>
</ul>
]]></content>
      <categories>
        <category>vim</category>
        <category>vimgolf</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>vimgolf</tag>
      </tags>
  </entry>
  <entry>
    <title>TODO</title>
    <url>/2020/06/25/TODO/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>需要一个todolist来管理我所有需要研究的todo:</p>
<h2 id="申论"><a href="#申论" class="headerlink" title="申论"></a>申论</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><ul>
<li>引用计数</li>
<li>Lambda 表达式有何用处？如何使用？ - KE meng的回答 - 知乎<br><a href="https://www.zhihu.com/question/20125256/answer/29733906" target="_blank" rel="noopener">https://www.zhihu.com/question/20125256/answer/29733906</a></li>
</ul>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><ul>
<li>程序员的自我修养</li>
<li>设计模式</li>
<li>teach yourself c++</li>
<li>黑客与画家</li>
<li>软件随想录</li>
</ul>
<h2 id="课程单"><a href="#课程单" class="headerlink" title="课程单"></a>课程单</h2><ul>
<li>现代c++30讲</li>
<li>c++课程(极客)</li>
<li>设计模式100(极客)</li>
<li>正则表达式(极客)</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>花时间研究一下vscode的debug模块</li>
<li>51cto买的课程</li>
</ul>
<h2 id="需要学习的技能"><a href="#需要学习的技能" class="headerlink" title="需要学习的技能"></a>需要学习的技能</h2><ul>
<li>设计模式</li>
<li>stl</li>
<li>正则表达式</li>
<li>python</li>
<li>完美消化掉科瑞的内容</li>
</ul>
<h2 id="其他杂项"><a href="#其他杂项" class="headerlink" title="其他杂项"></a>其他杂项</h2><h3 id="发现的新奇的东西"><a href="#发现的新奇的东西" class="headerlink" title="发现的新奇的东西"></a>发现的新奇的东西</h3><ul>
<li>无限注册邮箱小号 [[diary_2020-6-26.md]]</li>
</ul>
<h2 id="日记"><a href="#日记" class="headerlink" title="日记"></a>日记</h2>]]></content>
      <categories>
        <category>TODO</category>
      </categories>
      <tags>
        <tag>TODO</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_lambda用在哪里</title>
    <url>/2020/06/28/c-lambda%E7%94%A8%E5%9C%A8%E5%93%AA%E9%87%8C/</url>
    <content><![CDATA[<p>[TOC]</p>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式001-评判好代码的标准</title>
    <url>/2020/06/26/design_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F001-%E8%AF%84%E5%88%A4%E5%A5%BD%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="02-从那些维度评判代码质量的好坏"><a href="#02-从那些维度评判代码质量的好坏" class="headerlink" title="02-从那些维度评判代码质量的好坏"></a>02-从那些维度评判代码质量的好坏</h2><h3 id="可能的选项"><a href="#可能的选项" class="headerlink" title="可能的选项"></a>可能的选项</h3><p>灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可 读性（readability）、可理解性（understandability）、易修改性（changeability）、 可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦 合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性 （usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接 （straightforward）、少即是多（less code is more）、文档详尽（welldocumented）、分层清晰（well-layered）、正确性（correctness、bug free）、健 壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性 （scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）</p>
<h3 id="最强用的评价标准"><a href="#最强用的评价标准" class="headerlink" title="最强用的评价标准"></a>最强用的评价标准</h3><ul>
<li><ol>
<li>可维护性（maintainability）<br>如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。</li>
</ol>
</li>
<li><ol start="2">
<li>可读性（readability）<br>代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。</li>
</ol>
</li>
<li><ol start="3">
<li>可扩展性（extensibility）代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</li>
</ol>
</li>
<li><ol start="4">
<li>灵活性（flexibility）<br>当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。</li>
</ol>
</li>
<li><ol start="5">
<li>简洁性（simplicity）<br>思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本<br>质区别之一。</li>
</ol>
</li>
<li><ol start="6">
<li>可复用性（reusability）</li>
</ol>
</li>
<li><ol start="7">
<li>可测试性（testability）</li>
</ol>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。比如，面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等。</p>
]]></content>
      <categories>
        <category>coding</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式002-多态在不同语言中的实现</title>
    <url>/2020/06/26/design_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F002-%E5%A4%9A%E6%80%81%E5%9C%A8%E4%B8%8D%E5%90%8C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>多态在不同语言中的方式是不一样的.<br>主要分为两类:</p>
<p>对于多态特性的实现方式，除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式，一个是利用接口类语法，另一个是利用duck-typing语法。不过，并不是每种编程语言都支持接口类或者duck-typing这两种语法机制，比如C++就不支持接口类语法，而duck-typing只有一些动态语言才支持，比如Python、JavaScript等。</p>
<h3 id="继承的多态-c"><a href="#继承的多态-c" class="headerlink" title="继承的多态-c++"></a>继承的多态-c++</h3><h3 id="duck-typing"><a href="#duck-typing" class="headerlink" title="duck-typing"></a>duck-typing</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(“I write a log into file.”)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(“I insert data into db. ”)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(recorder)</span>:</span></span><br><span class="line">    recorder.record()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    logger = Logger()</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure>

<p>从这段代码中，我们发现，duck-typing 实现多态的方式非常灵活。Logger 和 DB 两个类没有任何关系，既不是继承关系，也不是接口和实现的关系，但是只要它们都有定义了 record() 方法，就可以被传递到 test() 方法中，在实际运行的时候，执行对应的 record() 方法。</p>
<p>也就是说，只要两个类具有相同的方法，就可以实现多态，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，通过继承实现多态特性，必须要求两个类之间有继承关系，通过接口实现多态特性，类必须实现对应的接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DynamicArray，才能将SortedDyamicArray传递给DynamicArray。第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法，也就是SortedDyamicArray重写了DynamicArray中的add（）方法。通过这三种语法机制配合在一起，我们就实现了在test（）方法中，子类SortedDyamicArray替换父类DynamicArray，执行子类SortedDyamicArray的add（）方法，也就是实现了多态特性。</p>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>project_公考行测</title>
    <url>/2020/06/27/project-%E5%85%AC%E8%80%83%E8%A1%8C%E6%B5%8B/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="时间和分值"><a href="#时间和分值" class="headerlink" title="时间和分值"></a>时间和分值</h2><p>时间是90分钟,按甲乙来分<br>具体参加什么具体等职位表出来再分析.<br>如果是延吉岗位没有的话,那么只好报名长春的岗位了.</p>
<p><img src="https://gitee.com/exarlos/blog_image/raw/master/20200626234459.png" alt="20200626234459"></p>
<p><img src="https://gitee.com/exarlos/blog_image/raw/master/20200627154357.png" alt="20200627154357"></p>
<h2 id="具体题型"><a href="#具体题型" class="headerlink" title="具体题型"></a>具体题型</h2><h3 id="常识-25个"><a href="#常识-25个" class="headerlink" title="常识(25个)"></a>常识(25个)</h3><p>甲乙是否难度一样呢?<br>好像部分政治题一样,剩下都不太一样.</p>
<h3 id="数字推理-2020年6月27日"><a href="#数字推理-2020年6月27日" class="headerlink" title="数字推理(2020年6月27日)"></a>数字推理(2020年6月27日)</h3><p>乙级有5个<br>如何判断是哪一个种类呢?</p>
<h4 id="0-真题"><a href="#0-真题" class="headerlink" title="0. 真题"></a>0. 真题</h4><ul>
<li>18年乙级</li>
</ul>
<ol>
<li>先求差,1*2</li>
<li>先求差,1+2</li>
<li>全都是2位数,机械拆解,互相差为等差数列</li>
<li>先求差,2=3*1</li>
<li>前三项之和</li>
</ol>
<h4 id="自己的总结"><a href="#自己的总结" class="headerlink" title="自己的总结"></a>自己的总结</h4><ol>
<li>首先判断给了几个选项,如果选项超过7个,那么就是3个以上参与度</li>
<li>再判断是不是一直增加,增加之后缓慢增加还是急速增加来判断是+还是*</li>
<li>如果有增减,那么就看是不是都是2位数,然后拆分</li>
<li>很偏爱先求差的选项</li>
</ol>
<h4 id="1-数字间涉及和、差"><a href="#1-数字间涉及和、差" class="headerlink" title="1. 数字间涉及和、差"></a>1. 数字间涉及和、差</h4><h4 id="2-乘除关系"><a href="#2-乘除关系" class="headerlink" title="2. 乘除关系"></a>2. 乘除关系</h4><h3 id="数学运算-2020年6月28日"><a href="#数学运算-2020年6月28日" class="headerlink" title="数学运算(2020年6月28日)"></a>数学运算(2020年6月28日)</h3><h4 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h4><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="1-概率题"><a href="#1-概率题" class="headerlink" title="1. 概率题"></a>1. 概率题</h5><p>要弄清楚,c和a的概率区别</p>
<h5 id="2-速度追赶题"><a href="#2-速度追赶题" class="headerlink" title="2. 速度追赶题"></a>2. 速度追赶题</h5><p>首先要记住一个公式,按时间平均走路,远比按路程一半走路高效..<br>因为有一个速度可能会超级慢.</p>
]]></content>
      <categories>
        <category>project</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式003-接口vs抽象类</title>
    <url>/2020/06/26/design_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F003-%E6%8E%A5%E5%8F%A3vs%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="08-理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口"><a href="#08-理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口" class="headerlink" title="08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口"></a>08 | 理论五：接口vs抽象类的区别？如何用普通的类模拟抽象类和接口</h2><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="抽象类是什么"><a href="#抽象类是什么" class="headerlink" title="抽象类是什么"></a>抽象类是什么</h3><ul>
<li>纯虚函数：没有函数体的虚函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">      <span class="keyword">private</span>:</span><br><span class="line">          <span class="keyword">int</span> a;</span><br><span class="line">      <span class="keyword">public</span>:</span><br><span class="line">          <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>抽象类：包含纯虚函数的类</li>
<li>只能作为基类来派生新类使用</li>
<li>不能创建抽象类的对象</li>
<li>抽象类的指针和引用 -&gt; 由抽象类派生出来的类的对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">A a;<span class="comment">//错，A 是抽象类，不能创建对象</span></span><br><span class="line">A *pa；<span class="comment">//ok，可以定义抽象类的指针和引用</span></span><br><span class="line">pa = <span class="keyword">new</span> A；<span class="comment">//错误，A 是抽象类，不能创建对象</span></span><br></pre></td></tr></table></figure>

<p>抽象类中</p>
<ul>
<li>在成员函数内可以调用纯虚函数</li>
<li>在构造函数/析构函数 内部不能使用纯虚函数</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口是什么"><a href="#接口是什么" class="headerlink" title="接口是什么"></a>接口是什么</h3><ul>
<li>接口不能包含属性（也就是成员变量）。</li>
<li>接口只能声明方法，方法不能包含代码实现。</li>
<li>类实现接口的时候，必须实现接口中声明的所有方法。</li>
</ul>
<h3 id="接口有什么用"><a href="#接口有什么用" class="headerlink" title="接口有什么用"></a>接口有什么用</h3><p>抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<h3 id="接口如何在c-里实现"><a href="#接口如何在c-里实现" class="headerlink" title="接口如何在c++里实现"></a>接口如何在c++里实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> &#123;</span> <span class="comment">// 用抽象类模拟接口</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ~Strategy();</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">algorithm</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    Strategy();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>抽象类Strategy没有定义任何属性，并且所有的方法都声明为virtual类型（等同于Java中的abstract关键字），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>抽象类和接口的语法特性抽象类不允许被实例化，只能被继承。它可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫作抽象方法。子类继承抽象类，必须实现抽象类中的所有抽象方法。接口不能包含属性，只能声明方法，方法不能包含代码实现。类实现接口的时候，必须实现接口中声明的所有方法。</li>
<li>抽象类和接口存在的意义抽象类是对成员变量和方法的抽象，是一种is-a关系，是为了解决代码复用问题。接口仅仅是对方法的抽象，是一种has-a关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代码的扩展性。</li>
<li>抽象类和接口的应用场景区别什么时候该用抽象类？什么时候该用接口？实际上，判断的标准很简单。如果要表示一种is-a的关系，并且是为了解决代码复用问题，我们就用抽象类；如果要表示一种has-a关系，并且是为了解决抽象而非代码复用问题，那我们就用接口。</li>
</ol>
]]></content>
      <categories>
        <category>coding</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>十年磨一剑</title>
    <url>/2020/06/23/article_%E5%8D%81%E5%B9%B4%E7%A3%A8%E4%B8%80%E5%89%91/</url>
    <content><![CDATA[<h1 id="十年磨一剑"><a href="#十年磨一剑" class="headerlink" title="十年磨一剑"></a>十年磨一剑</h1><p><a href="https://www.douban.com/note/339220850/" target="_blank" rel="noopener">https://www.douban.com/note/339220850/</a></p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>从校队退役之后，每到下午四点钟都有一种坐立不安的感觉，惶惶然好像少了些什么。新英格兰十一月后便有小半年大雪封山，晨跑也难以执行。我每天不运动个把小时就浑身难受（我的阿宅闺蜜说她但凡运动了就一整天浑身难受），没有私车背着装备坐地铁去击剑馆又实在太麻烦，于是兴起去波士顿芭蕾学院报了成人课。<br>波士顿芭蕾学院隶属于波士顿芭蕾剧团，学员中不乏准职业舞者。那些十三四岁穿着雪白长袜的少女在镜前旋转跳跃，小脸上满满都是年轻的骄傲。待她们嬉笑着从练功房离开后便轮到我们这些老胳膊老腿的业余爱好者登场。同我一起上课的有旁边大学的学生，有职场白领，家庭妇女，甚至还有鸡皮鹤发的老爷爷老奶奶。换上舞鞋似乎消磨了大家之间年龄和阶级的差异，让我们如同那生活尚未开始的少年舞者一样面目相似。<br>有一天我耽搁了一会才回到更衣室，旁边有个胖胖的中年女人缓慢地套上旧毛衣阔腿裤，系上旅游鞋带，摇摇摆摆神情冷淡地关门而去。<br>我突然想起来刚才课上她就在我旁边，而我却没有认出她来。<br>走出明亮的芭蕾练功房，我们把现实一件一件穿回身上，臃肿地走回波士顿的寒冬里，他们不会知道，在这沉默肮脏的街道上，在层层叠叠斑斓羽绒服构成的人海中，在肥胖冷漠的家庭妇女办公职员中学教师之间藏了一个芭蕾舞者。</p>
<p>我拎着舞鞋在雪地里深一脚浅一脚地走回家，电车停运真是这个城市最能让人窘迫地一件事情，我进了绿线旁一个一直路过但不曾造访的咖啡馆，打算点杯热巧克力暖暖手。<br>收银台打工的女孩突然开口说，你是wellesley佩剑队的主力对吗。<br>我抬头定睛看她的脸。<br>这超过了我日常在咖啡馆里“天气不错谢谢你不用客气美好一天”的对话范围。<br>我是波士顿大学的佩剑队员。<br>我记得她。我们在2011年新英格兰击剑锦标赛上交过手。<br>也许人海和现实并不如我想象的那样让所有面孔千篇一律，总会有人认出你——那些和你同样从事过并且热爱着那项运动的人。</p>
<p>击剑的圈子很小，新英格兰赛事上常见熟面孔：某届奥运老将，美国国家队队员，某届奥运裁判都会露脸，而且还喜欢赛后和选手指点一二（可是比起来他们的指点我更想和他们打一局十五剑……）；我小时候在北京打少年赛的时候一些高居榜首的名字后来在重要赛事上都有看到。更多的名字只是消失不见。<br>这不是一个流行的运动，即便当中有谁成了世界顶级的击剑手，他／她也不会像网球或足球明星那样腰缠万贯受人瞩目。但我依然会记得他们，每一个人，每一个学校教练带出来的风格：cornell的蛇形步，tufts的旋剑击打进攻，brandeis的挑剑刺……不论他们去往何方。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>好像所有的社交网站都被健身发烧友占领了，经常就会冒出来姑娘小伙对着镜子收腹提臀的半裸照，这样的傲人成果自然让人心痒，于是有很多人在下面跟贴：怎样练下腹啊怎样把屁股练翘又不把腿练粗……<br>我对于健身热潮并不怎么感冒，从心里我认为人体骨骼肌肉之精妙远远超过人类现在所能发明的任何健身甚至整形技术——信不信随你，我们远没有达到“指哪打哪”的水平，现在没有，未来很长一段时间之内也不会。诚然我们可以努力去优化自己的形体（降低脂肪含量，加强柔韧性，强化肌肉力量等等），但是“我要让大腿围低于xx公分”“我只想练臀部肌肉不想练腿”“我只想去掉大臂下面的脂肪但是不要练上面的肌肉”这样的目标未免可笑。让职业健美人士随意抨击我吧，我固执地认为人的形体并不是秀身材的相册中拼接的那样，人体不是八块腹肌胸大肌臀大肌肱二头肌的零散组合。肌肉骨骼之间丝缕相扣，它们不会彼此脱离单独存在，更不可能人为地抑此扬彼。<br>确实有很多人通过练器械的方式获得了健美漂亮的身材，如此实图证据在互联网上比比皆是，我很敬佩他们的毅力。但是有的时候我会想：我们欣赏一个人健美的身材是仅仅出于视觉上的享受吗？健美的身材是一个人协调能力和运动潜力的外在表现，而为了去“秀什么”而急功近利地恶补某些肌肉群是追求这样能力的结果却摒弃了其源头，多少有些本末倒置。<br>我所认识的职业运动员和舞蹈家似乎肌肉块头都没健美狂热爱好者那么壮硕，线条也不那么分明。视觉效果确实来得不够快也不够好，只是我更欣赏从有机使用中锻炼起来而不是通过器械重复而来的身体。曾住在我公寓旁边的健身教练胳膊比脑袋还粗，薄衬衫撑得满满（每次和他一起坐电梯都觉得电梯间格外小）。相反的，我总惊艳于一些除了强硕肌肉以外的东西——我无法忘怀在电车里的芭蕾舞者挺拔优雅仿佛舞台随她而在，退役的棒球运动员和他的爱犬玩耍时以一个出奇漂亮的弧线将球抛出，或是足球运动员在街边用足尖轻松挑起易拉罐——他们没人有夸张的肌肉，甚至上了年纪的人还有点小肚子，他们不是健美先生，不是性感辣妹，但那透露出他们曾经投身运动和舞蹈生涯的小细节让我觉得他们很美。<br>仔细算我练击剑断断续续将近十年，甚至从校队里退役都有一段时间了。可惜我不够努力，也不够有天分，这十年并没有给漂亮的身材和优雅的姿态，击剑给我留下的大概只有大家笑称的“只要桌上有个击剑运动员就不会有倾倒的水杯”。<br>水杯倾倒是一个缓慢的过程，你看那水液激起波澜突破平衡，就像是你在训练时做了千百遍的：在那手套从教练手中落下的毫秒之间爆发出一个弓步将它接住。<br>你伸手顺势接住那水杯放回桌上的一刻时间恢复正常运转，身边人啧啧称奇，杯中水有一个微妙的漩涡。<br>于是你笑笑，仿佛真的可以在那一瞬间草芥之人可以向时间和重力扳回一城。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>芭蕾起源于对击剑的舞蹈诠释，我总以为那原因是击剑本身的观赏度实在不高。影视作品中经常让高帅富们拿着花剑像打佩剑一样劈砍还一边炫酷地上蹿下跳聊着自己那点破事。真实的击剑在外行人眼中就是两个穿得鼓鼓囊囊的人拿着根棍互相戳：<br>如果是花剑或者重剑——“好无聊啊，他们怎么都不出手的啊”<br>如果是佩剑——“怎么回事？打完了？为什么他赢了啊？”<br>我很难向不了解击剑的人解释两个花剑手来回击打对方的剑而不轻易发起进攻是在调控把握双方的节奏，一次冒失的进攻是徒然地把自己送到对方剑下；两个重剑手可能在最后的十几秒里都消极防御是因为在等加时赛；那些被外行人称为“又细又软”的剑体实际上是高韧度的钢条，在职业运动员强劲的腕力下可以瞬间从直的甩成了弯的。<br>我也不愿让他们失望，告诉他们其实真实的击剑场上没有佐罗电影里那样华丽的大幅劈砍跳跃。跌跌撞撞用蛮力拿着剑挥来挥去的大多是初学者，而高手过招胜负在毫厘之间，灯亮喊停，点到为止。</p>
<p>无论是专业运动员还是业余爱好者，正确习惯的养成都很重要：大家往往都是私教课上被教练一个个动作纠正过去，挂上金属线一上场实战就又是张牙舞爪的老样子。我刚刚开始练击剑的时候是十三岁，和几个同龄的小伙伴一起蹲马步，为了步伐不变形。练弓步的时候，膝盖压过了足尖教练就一剑抽在腿上。一节课是满打满算的一个小时，打完就去操场跑二十圈，被套圈的人再罚五圈，套了别人圈的人减两圈——跑吐了去漱口回来接着跑……因为跑步、输剑或是被教练骂，我们几个好朋友当时都哭过鼻子。后来和朋友聊天，说现在剑馆里小孩子这样的练法早就被家长投诉了，但是也练不出来了。我在美国大学里校训的第一天被教练点出来，说弓步打得好，而我但凡弓步变形心里都一抽，觉得教练那剑条又要抽到腿上来了。在美国的四年里总觉得教练并没有在在国内练的时候严格，回国夏天训练的时候总被他们笑腕部动作不精细——“你这分明就是男佩的打法嘛”。<br>就像跳舞时如果想着：下一步要跳起，跳完之后要交叉步，然后是什么呢……一定会跳成一个木头人。我很怀疑武侠小说里面两个剑客巅峰对决之刻，见招拆招间忽见对方神情有异，想起该派系脉门所在，于是心生一计因对方上当并予以致命一击。更让人匪夷所思的是有人在劲敌当前生死一线之际竟然会灵魂出窍想起初恋的寄托师父的教诲甚至当场顿悟出制胜之策来，简直让人质疑这样不敬业的剑客是怎么当上绝顶高手的——小学生打群架都知道走神是要挨板砖的好吗……</p>
<p>你的身体哪怕在接受专业训练后的很长一段时间里也都比你的大脑要聪明。当你告诉它：先抬腿，旋转，然后同时手臂平衡的时候，就像是一个小学生让大学教授根据老师布置的作业用图像法做加减乘除一样笨拙。很多时候，无论是运动还是舞蹈，闭上眼睛，跟着旋律，你的身体会自然而然地把它做得很好，而优秀的运动员和舞者也是将复杂地动作以超乎常人地自然流畅表现出来，只是那举重若轻背后往往是多年苦功，让一个动作通过反复纠正内化至不需要经过大脑指导便可以完美地再现出来：训练有素的芭蕾舞者只需要一个最简单的单腿旋转就足以证明为什么她可以是女主角而旁人只能是配角；一个优秀的击剑运动员面对对手最有利的优势并不是能做出漂亮的三次防守反击或是甩剑刺（对于佩剑来说，即便是在顶级赛事上很多得分也都是进攻反攻，或者一次防守反击）。一个入门的击剑手在两个星期里就可以学会基本的步伐和手部动作，然而在赛场上打出一个距离都大并且被对方格挡后可以及时收回的弓步或是做出一个漂亮精准不变形的转移，往往都是多年严苛训练的结果。<br>击剑的基础动作很简单，大概新手学习两个月之后就能掌握基本的步伐和手法。事实上，对于绝大部分职业击剑运动员来说，能够真正精通并且打得好的套路也就那么三五个。<br>我学击剑三个月后就被教练送去北京市的少年赛，我还记得当时的自己面对体校人高马大的初中生们急中生智，只一味往后退一边用剑乱比划，如果侥幸碰到了对方的剑就闭着眼睛往前打，竟然也误打误撞地得了好几个“防守还击”。<br>很多年之后，在麻省理工邀请赛上，我有幸和蝉联两届新英格兰佩剑冠军的选手对战，胜率渺茫，遇到难得的强敌，唯有放手一搏证明对方遇到你也不容易。那一场比赛输得意料之中，但是我激动异常——在对方的攻势下，我像十年前的自己一样选择等待对方发起进攻时的破绽，并且成功地防守还击得分——把十三岁时学的基本动作打磨成自己肢体记忆的一部分，我花了整整十年的时间。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>击剑实在不是个流行的运动，即便在大城市里也很难找到剑馆，其中学员不是初学者就是刚刚比剑身高过一点的小孩子，写完这篇文章的初稿后我觉得自己大概从此以后是很少有时间能够继续这项运动了。<br>不料到了牛津之后，去了几次击剑试训，打了两次小组赛后被录入校队，从此日程表上又排满了南征北战——每次赴邀请赛我都觉得自己像是个下山的堂吉诃德，清晨四点背着沉沉的铠甲和长剑，迷迷糊糊地赶到集合的地方，在半睡半醒中看着车窗外静默的树木和小镇在烟雨中一一后退，巴士停下，你扛着剑包跟着人往前走，行装的重量加在睡意上，一步挨着另一步。<br>直到进了场地的那一瞬间才是猛地醒了，你环顾四周，有人在张贴比赛名册，有人在搬有人在跑道上热身，各个学校的队长们吆喝着自己的运动员去检录……<br>你不作声地打量他们的体格身高，留意他们在场边的热身赛，心里大致掂量他们的速度和习惯——也许有些狡猾，但是全场的每一个人都在这样做——而直到他们换上自己的剑服你才能完全确定哪些人将会是你在这一场比赛中的对手，如果你足够细心，上场之前大概已经可以看出几个人的底细：谁是新手谁是老将，谁被教练刚刚换了剑种，还有谁是左撇子。<br>大多数时候击剑比赛都是在体育馆里，除了在英国很不可预测…牛津和帝国理工的邀请赛是在某个礼堂里进行的，主办方竟然在挂满油画并且摆满新古典主义雕塑的大厅里拉开两条剑道，那一刻真是仿佛到了中世纪进行决斗——幕布升起，满满烛光闪耀，你和你的对手分别走上剑道，头顶是高高腾起的穹顶，而那四周的油画和陈列台上，你的观众是凯撒圣母玛利亚亚里士多德，他们神情各异，用目光和手指示意着各个不同的方向……</p>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>踏上剑道，戴上护面，敬裁判，敬对手，之后心中总是一片空白。<br>此时你的肾上腺激素狂飙，毛孔张开寒毛竖起瞳孔缩小，每一寸肌肉都蓄势待发。你知道裁判手落之际一切都将启动。你的步伐紧凑绵密，酝酿着一个爆发的弓步，你格开对方的剑，剑柄重重震动虎口——对战双方都是拉满的弓。<br>于是你抽手吊剑，剑尖在击中他护手盘的一刻被强力折弯，弹中他的手肘如行云流水。巨大的喜悦感在你心中炸裂，队友的呐喊裁判的指令在背景音中淡成一片，你只知道这一刻之美妙之不可言，它超过了打麻将连胡三手牌超过了暴雨天里的鸡汤面和盛夏酷暑的冰啤酒，好过拿offer，好过白日梦，好过人世间最好之事，甚至有那么一瞬，你觉得它好过自由，好过生命。<br>而尝过一次这滋味后，你便会为了它去付出成百上千个孤独的下午，去练习那个吊手刺，直到肌肉酸软，直到被汗水浸透。<br>那是我少女时代每一个暑假的下午，十三岁，十四岁，十五岁，十六岁，在剑馆里大汗淋漓地练静蹲，弓步，劈砍。靶人的旁边被人玩笑式地贴了一张海报，上面写着：生活就是一个弓步，又一个弓步。<br>许多年前的我劈叉压弓步的时候痛得咬着牙看着这句话在心里读了很多遍只是为了读点什么让那一分一秒过得快点。<br>而我至今都记着那句话，并且如此相信着。</p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title>01-堆,栈,RAII</title>
    <url>/2020/06/23/c-01-%E5%A0%86-%E6%A0%88-RAII/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h2 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h2><h3 id="RAII的基本用法"><a href="#RAII的基本用法" class="headerlink" title="RAII的基本用法"></a>RAII的基本用法</h3><p>在析构函数里做必要的清理工作，这就是 RAII 的基本用法。这种清理并不限于释放内存，也可以是：</p>
<ul>
<li>关闭文件（fstream 的析构就会这么做）</li>
<li>释放同步锁</li>
<li>释放其他重要的系统资源</li>
</ul>
<hr>
<h3 id="RAII是为什么-没太明白"><a href="#RAII是为什么-没太明白" class="headerlink" title="RAII是为什么(没太明白)"></a>RAII是为什么(没太明白)</h3><p>C++ 支持将对象存储在栈上面。但是，在很多情况下，对象不能，或不应该，存储在栈上。比如：</p>
<p>对象很大；<br>对象的大小在编译时不能确定；<br>对象是函数的返回值，但由于特殊的原因，不应使用对象的值返回。</p>
<p>常见情况之一是，在工厂方法或其他面向对象编程的情况下，返回值类型是基类。下面的例子，是对工厂方法的简单演示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">shape_type</span> &#123;</span></span><br><span class="line">  <span class="built_in">circle</span>,</span><br><span class="line">  triangle,</span><br><span class="line">  rectangle,</span><br><span class="line">  …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span> &#123;</span> … &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">circle</span> :</span> <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">triangle</span> :</span> <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span> :</span> <span class="keyword">public</span> shape &#123; … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">shape* <span class="title">create_shape</span><span class="params">(shape_type type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> shape_type::<span class="built_in">circle</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">circle</span>(…);</span><br><span class="line">  <span class="keyword">case</span> shape_type::triangle:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> triangle(…);</span><br><span class="line">  <span class="keyword">case</span> shape_type::rectangle:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> rectangle(…);</span><br><span class="line">  …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们怎样才能确保，在使用 create_shape 的返回值时不会发生内存泄漏呢？</p>
<p>答案就在析构函数和它的栈展开行为上。我们只需要把这个返回值放到一个本地变量里，并确保其析构函数会删除该对象即可。一个简单的实现如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape_wrapper</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">shape_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    shape* ptr = <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="function">    : <span class="title">ptr_</span><span class="params">(ptr)</span> </span>&#123;&#125;</span><br><span class="line">  ~shape_wrapper()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">shape* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ptr_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  shape* ptr_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="function">shape_wrapper <span class="title">ptr_wrapper</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    create_shape(…))</span></span>;</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>08_智能指针smart_ptr</title>
    <url>/2020/06/25/c-08-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88smart-ptr/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><ul>
<li>unique_ptr实际上并不是指针.而是一个对象</li>
<li>不要用delete</li>
<li>也没有++,–等操作,避免越界</li>
<li>这个一定要初始化之后再用</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;      <span class="comment">// int智能指针</span></span><br><span class="line">assert(*ptr1 = <span class="number">10</span>);                     <span class="comment">// 可以使用*取内容</span></span><br><span class="line">assert(ptr1 != <span class="literal">nullptr</span>);                <span class="comment">// 可以判断是否为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>))</span></span>;  <span class="comment">// string智能指针</span></span><br><span class="line">assert(*ptr2 == <span class="string">"hello"</span>);                <span class="comment">// 可以使用*取内容</span></span><br><span class="line">assert(ptr2-&gt;<span class="built_in">size</span>() == <span class="number">5</span>);               <span class="comment">// 可以使用-&gt;调用成员函数</span></span><br></pre></td></tr></table></figure>

<h3 id="make-unique-来强制初始化"><a href="#make-unique-来强制初始化" class="headerlink" title="make_unique()来强制初始化"></a>make_unique()来强制初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr3 = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);               <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line">assert(ptr3 &amp;&amp; *ptr3 == <span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr4 = make_unique&lt;<span class="built_in">string</span>&gt;(<span class="string">"god of war"</span>);  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line">assert(!ptr4-&gt;empty());</span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr的所有权"><a href="#unique-ptr的所有权" class="headerlink" title="unique_ptr的所有权"></a>unique_ptr的所有权</h3><p>指针的所有权是“唯一”的，不允许共享，任何时候只能有一个“人”持有它。<br>为了实现这个目的，unique_ptr应用了C++的“转移”（move）语义，同时禁止了拷贝赋值，所以，在向另一个unique_ptr赋值的时候，要特别留意，必须用std::move()函数显式地声明所有权转移。<br>赋值操作之后，指针的所有权就被转走了，原来的unique_ptr变成了空指针，新的unique_ptr接替了管理权，保证所有权的唯一性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);    <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line">assert(ptr1 &amp;&amp; *ptr1 == <span class="number">42</span>);         <span class="comment">// 此时智能指针有效</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr2 = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr1);         <span class="comment">// 使用move()转移所有权</span></span><br><span class="line">assert(!ptr1 &amp;&amp; ptr2);               <span class="comment">// ptr1变成了空指针</span></span><br></pre></td></tr></table></figure>

<h2 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h2><h3 id="shared-ptr用法"><a href="#shared-ptr用法" class="headerlink" title="shared_ptr用法"></a>shared_ptr用法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;     <span class="comment">// int智能指针</span></span><br><span class="line">assert(*ptr1 = <span class="number">10</span>);                    <span class="comment">// 可以使用*取内容</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>))</span></span>;  <span class="comment">// string智能指针</span></span><br><span class="line">assert(*ptr2 == <span class="string">"hello"</span>);                      <span class="comment">// 可以使用*取内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line">assert(ptr3 &amp;&amp; *ptr3 == <span class="number">42</span>);       <span class="comment">// 可以判断是否为空指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr4 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">"zelda"</span>);  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line">assert(!ptr4-&gt;empty());                   <span class="comment">// 可以使用-&gt;调用成员函数</span></span><br></pre></td></tr></table></figure>

<h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>它的所有权是可以被安全共享的，也就是说支持拷贝赋值，允许被多个“人”同时持有，就像原始指针一样。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ptr1 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);    <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line">assert(ptr1 &amp;&amp; ptr1.unique() );     <span class="comment">// 此时智能指针有效且唯一</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ptr2 = ptr1;                  <span class="comment">// 直接拷贝赋值，不需要使用move()</span></span><br><span class="line">assert(ptr1 &amp;&amp; ptr2);              <span class="comment">// 此时两个智能指针均有效</span></span><br><span class="line"></span><br><span class="line">assert(ptr1 == ptr2);             <span class="comment">// shared_ptr可以直接比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个智能指针均不唯一，且引用计数为2</span></span><br><span class="line">assert(!ptr1.unique() &amp;&amp; ptr1.use_count() == <span class="number">2</span>);</span><br><span class="line">assert(!ptr2.unique() &amp;&amp; ptr2.use_count() == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>循环引用-把shared_ptr作为类成员的时候最容易出现，典型的例子就是链表节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> this_type     = Node;</span><br><span class="line">    <span class="keyword">using</span> shared_type   = <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;this_type&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_type     next;      <span class="comment">// 使用智能指针来指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n1 = make_shared&lt;Node&gt;();   <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="keyword">auto</span> n2 = make_shared&lt;Node&gt;();   <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"></span><br><span class="line">assert(n1.use_count() == <span class="number">1</span>);    <span class="comment">// 引用计数为1</span></span><br><span class="line">assert(n2.use_count() == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">n1-&gt;next = n2;                 <span class="comment">// 两个节点互指，形成了循环引用</span></span><br><span class="line">n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">assert(n1.use_count() == <span class="number">2</span>);    <span class="comment">// 引用计数为2</span></span><br><span class="line">assert(n2.use_count() == <span class="number">2</span>);    <span class="comment">// 无法减到0，无法销毁，导致内存泄漏</span></span><br></pre></td></tr></table></figure>

<h2 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h2><p>weak_ptr顾名思义，功能很“弱”。它专门为打破循环引用而设计，只观察指针，不会增加引用计数（弱引用），但在需要的时候，可以调用成员函数lock()，获取shared_ptr（强引用）。</p>
<p>刚才的例子里，只要你改用weak_ptr，循环引用的烦恼就会烟消云散：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> this_type     = Node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里，别名改用weak_ptr</span></span><br><span class="line">    <span class="keyword">using</span> shared_type   = <span class="built_in">std</span>::weak_ptr&lt;this_type&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_type     next;    <span class="comment">// 因为用了别名，所以代码不需要改动</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> n1 = make_shared&lt;Node&gt;();  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"><span class="keyword">auto</span> n2 = make_shared&lt;Node&gt;();  <span class="comment">// 工厂函数创建智能指针</span></span><br><span class="line"></span><br><span class="line">n1-&gt;next = n2;             <span class="comment">// 两个节点互指，形成了循环引用</span></span><br><span class="line">n2-&gt;next = n1;</span><br><span class="line"></span><br><span class="line">assert(n1.use_count() == <span class="number">1</span>);    <span class="comment">// 因为使用了weak_ptr，引用计数为1</span></span><br><span class="line">assert(n2.use_count() == <span class="number">1</span>);   <span class="comment">// 打破循环引用，不会导致内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!n1-&gt;next.expired()) &#123;     <span class="comment">// 检查指针是否有效</span></span><br><span class="line">    <span class="keyword">auto</span> ptr = n1-&gt;next.lock();  <span class="comment">// lock()获取shared_ptr</span></span><br><span class="line">    assert(ptr == n2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>智能指针是代理模式的具体应用，它使用RAII技术代理了裸指针，能够自动释放内存，无需程序员干预，所以被称为“智能指针”。</li>
<li>如果指针是“独占”使用，就应该选择unique_ptr，它为裸指针添加了很多限制，更加安全。</li>
<li>如果指针是“共享”使用，就应该选择shared_ptr，它的功能非常完善，用法几乎与原始指针一样。</li>
<li>应当使用工厂函数make_unique()、make_shared()来创建智能指针，强制初始化，而且还能使用auto来简化声明。</li>
<li>shared_ptr有少量的管理成本，也会引发一些难以排查的错误，所以不要过度使用。</li>
</ol>
<p>我还有一个很重要的建议：</p>
<p>既然你已经理解了智能指针，就尽量不要再使用裸指针、new和delete来操作内存了。</p>
<p>如果严格遵守这条建议，用好unique_ptr、shared_ptr，那么，你的程序就不可能出现内存泄漏.</p>
<h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2><ul>
<li>你觉得unique_ptr和shared_ptr的区别有哪些？列举一下。</li>
<li>你觉得应该如何在程序里“消灭”new和delete？</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>assert是什么</title>
    <url>/2020/06/24/c-assert%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<ul>
<li>assert的头文件在&lt;assert.h&gt;里</li>
<li>assert只有在debug模式生效</li>
<li><code>#define NDEBUG assert</code> 在头文件前面添加这个,可以使assert失效</li>
<li><code>#define DEBUG</code> 可以重新生效</li>
</ul>
<h2 id="assert的用法"><a href="#assert的用法" class="headerlink" title="assert的用法"></a>assert的用法</h2><p>assert是宏，而不是函数。它的原型定义在头文件 assert.h 中：</p>
<p><code>void assert( int expression );</code></p>
<p>宏 assert 经常用于在函数开始处检验传入参数的合法性，可以将其看作是异常处理的一种高级形式。assert 的作用是先计算表达式expression，然后判断：</p>
<blockquote>
<p><strong>如果表达式值为假，那么它先向stderr打印错误信息，然后通过调用 abort 来终止程序运行。</strong><br><strong>如果表达式值为真，继续运行后面的程序。</strong></p>
</blockquote>
<p>注意：assert只在 DEBUG 下生效，在调试结束后，可以通过在#include &lt;assert.h&gt;语句之前插入#define NDEBUG来禁用assert调用。</p>
<h2 id="assert什么时候使用呢"><a href="#assert什么时候使用呢" class="headerlink" title="assert什么时候使用呢"></a>assert什么时候使用呢</h2><p>比如说手写strcpy函数的时候.</p>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>const,volatile,mutable</title>
    <url>/2020/06/25/c-const-volatile-mutable/</url>
    <content><![CDATA[<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>const最好不要放在*的右边,没有太大意义</li>
<li>const只是语法上的const,实际上用指针是能修改的</li>
<li>成员函数里面设置为const意味着,里面是个只读操作</li>
<li>如果想要修改私有变量,但同时函数设置为const,那么就把变量设置为mutable</li>
</ul>
<h2 id="mutable"><a href="#mutable" class="headerlink" title="mutable"></a>mutable</h2><p>对于这些有特殊作用的成员变量，你可以给它加上mutable修饰，解除const的限制，让任何成员函数都可以操作它。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoClass</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> mutex_type  m_mutex;    <span class="comment">// mutable成员变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save_data</span><span class="params">()</span> <span class="keyword">const</span>          <span class="comment">// const成员函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do someting with m_mutex</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>它表示变量可能会被“不被察觉”地修改，禁止编译器优化，影响性能，应当少用。<br>几乎没啥用</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.const</p>
<p>它是一个类型修饰符，可以给任何对象附加上“只读”属性，保证安全；<br>它可以修饰引用和指针，“const &amp;”可以引用任何类型，是函数入口参数的最佳类型；<br>它还可以修饰成员函数，表示函数是“只读”的，const对象只能调用const成员函数。</p>
<p>2.volatile</p>
<p>它表示变量可能会被“不被察觉”地修改，禁止编译器优化，影响性能，应当少用。</p>
<p>3.mutable</p>
<p>它用来修饰成员变量，允许const成员函数修改，mutable变量的变化不影响对象的常量性，但要小心不要误用损坏对象。</p>
<p><img src="https://gitee.com/exarlos/blog_image/raw/master/20200625165916.png" alt="20200625170856"></p>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>strcpy/strlen/strcat/strcmp的实现</title>
    <url>/2020/06/24/c-strcpy-strlen-strcat-strcmp%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h2 id="1-字符串拷贝strcpy"><a href="#1-字符串拷贝strcpy" class="headerlink" title="1. 字符串拷贝strcpy"></a>1. 字符串拷贝strcpy</h2><p>函数strcpy的原型是<code>char* strcpy(char* des , const char* src)</code>，des 和 src 所指内存区域不可以重叠且 des 必须有足够的空间来容纳 src 的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  assert((des!=<span class="literal">NULL</span>) &amp;&amp; (src!=<span class="literal">NULL</span>));</span><br><span class="line">  <span class="keyword">if</span> (des == src)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> des;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span> *address = des;</span><br><span class="line">  <span class="keyword">while</span>((*des++ = *src++) != <span class="string">'\0'</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要知道 strcpy 会拷贝’\0’，还有要注意：</p>
<blockquote>
<p>源指针所指的字符串内容是不能修改的，因此应该声明为 const 类型。<br>要判断源指针和目的指针为空的情况，思维要严谨，这里使用assert（见文末）。<br>要用一个临时变量保存目的串的首地址，最后返回这个首地址。<br>函数返回 char* 的目的是为了支持链式表达式，即strcpy可以作为其他函数的实参。</p>
</blockquote>
<h3 id="为什么不返回src的原始值，错误原因有以下三点"><a href="#为什么不返回src的原始值，错误原因有以下三点" class="headerlink" title="为什么不返回src的原始值，错误原因有以下三点"></a>为什么不返回src的原始值，错误原因有以下三点</h3><p>源字符串本来就已知，返回没有什么意义<br>    不能支持形如char * strA = strcpy(new char[10],strB) 这样的表达式<br>    为了保护源字符串，使用const限定了src所指的内容，把const char作为char的返回值，类型不符，编译器会报错。</p>
<h3 id="strcpy和memcpy的不同点"><a href="#strcpy和memcpy的不同点" class="headerlink" title="strcpy和memcpy的不同点"></a>strcpy和memcpy的不同点</h3><p>这个也是常见的考点，主要分为以下三点不同：</p>
<p>复制内容不同：strcpy只能复制字符串，而memcpy可以复制任何内容，例如字符数组，整型，结构体等<br>    复制的方法不同：strcpy不需要指定长度，它遇到字符串结束符’\0’才结束，所以容易溢出。memcpy则需要传入第三个参数来指定长度<br>    用途不同：通常在复制字符串的时候用strcpy，而需要复制其他数据类型的时候则一般用memcpy。</p>
<h2 id="2-字符串长度strlen"><a href="#2-字符串长度strlen" class="headerlink" title="2. 字符串长度strlen"></a>2. 字符串长度strlen</h2><p>函数strlen的原型是<code>size_t strlen(const char *s)</code>，其中 <code>size_t</code> 就是 <code>unsigned int</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> assert(str != <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>((*str++) != <span class="string">'\0'</span>)</span><br><span class="line">  ++len;</span><br><span class="line"> <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>strlen 与 sizeof 的区别：</p>
<ul>
<li><p>sizeof是运算符，strlen是库函数。</p>
</li>
<li><p>sizeof可以用类型、变量做参数，而strlen只能用 char* 变量做参数，且必须以\0结尾。</p>
</li>
<li><p>sizeof是在编译的时候计算类型或变量所占内存的大小，而strlen的结果要在运行的时候才能计算出来，用来计算字符串的长度。</p>
</li>
<li><p>数组做sizeof的参数不退化，传递给strlen就退化为指针了。</p>
</li>
</ul>
<h2 id="3-字符串连接strcat"><a href="#3-字符串连接strcat" class="headerlink" title="3. 字符串连接strcat"></a>3. 字符串连接strcat</h2><p>函数<strong>strcat</strong>的原型是<code>char* strcat(char* des, char* src)</code>，<strong>des</strong> 和 <strong>src</strong> 所指内存区域不可以重叠且 <strong>des</strong> 必须有足够的空间来容纳 <strong>src</strong> 的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span>* des, <span class="keyword">const</span> <span class="keyword">char</span>* src)</span>   <span class="comment">// const表明为输入参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> assert((des!=<span class="literal">NULL</span>) &amp;&amp; (src!=<span class="literal">NULL</span>));</span><br><span class="line"> <span class="keyword">char</span>* address = des;</span><br><span class="line"> <span class="keyword">while</span>(*des != <span class="string">'\0'</span>)  <span class="comment">// 移动到字符串末尾</span></span><br><span class="line">  ++des;</span><br><span class="line"> <span class="keyword">while</span>(*des++ = *src++)</span><br><span class="line">  ;</span><br><span class="line"> <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-字符串比较strcmp"><a href="#4-字符串比较strcmp" class="headerlink" title="4. 字符串比较strcmp"></a>4. 字符串比较strcmp</h2><p>函数<code>strcmp</code>的原型是<code>int strcmp(const char *s1,const char *s2)</code>。</p>
<p>若s1==s2，返回零；<br>若s1&gt;s2，返回正数；<br>若s1&lt;s2，返回负数。</p>
<p>两个字符串自左向右逐个字符相比（按ASCII值大小相比较），直到出现不同的字符或遇\0为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s1,<span class="keyword">const</span> <span class="keyword">char</span> *s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> assert((s1!=<span class="literal">NULL</span>) &amp;&amp; (s2!=<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*s1 == *s2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*s1 == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        ++s1;</span><br><span class="line">        ++s2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *s1 - *s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++_编码规范1</title>
    <url>/2020/06/28/c-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%831/</url>
    <content><![CDATA[<p>[TOC]</p>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><h3 id="利用上下文简化命名"><a href="#利用上下文简化命名" class="headerlink" title="利用上下文简化命名"></a>利用上下文简化命名</h3><p>在User类这样一个上下文中，我们没有在成员变量的命名中重复添加“user”这样一个前缀单词，而是直接命名为name、password、avatarUrl。在使用这些属性时候，我们能借助对象这样一个上下文，表意也足够明确。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> userName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> userPassword;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> userAvatarUrl;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样就足够了</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.getName(); <span class="comment">// 借助 user 对象这个上下文</span></span><br></pre></td></tr></table></figure>

<h3 id="如何命名接口和抽象类"><a href="#如何命名接口和抽象类" class="headerlink" title="如何命名接口和抽象类"></a>如何命名接口和抽象类</h3><p>对于接口的命名，一般有两种比较常见的方式。一种是加前缀“I”，表示一个Interface。比如IUserService，对应的实现类命名为UserService。另一种是不加前缀，比如UserService，对应的实现类加后缀“Impl”，比如UserServiceImpl。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，比如AbstractConfiguration；另一种是不带前缀“Abstract”。实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。</p>
<h3 id="注释要写什么"><a href="#注释要写什么" class="headerlink" title="注释要写什么"></a>注释要写什么</h3><p>做什么、为什么、怎么做。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* (what) Bean factory to create beans.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* (why) The class likes Spring IOC framework, but is more lightweight.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* (how) Create objects from different sources sequentially:</span></span><br><span class="line"><span class="comment">* user specified object &gt; SPI &gt; configuration &gt; default object.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansFactory</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><h3 id="类、函数多大才合适"><a href="#类、函数多大才合适" class="headerlink" title="类、函数多大才合适"></a>类、函数多大才合适</h3><ol>
<li>不要超过一个显示屏的垂直高度,大概50左右吧</li>
</ol>
<h2 id="编程技巧"><a href="#编程技巧" class="headerlink" title="编程技巧"></a>编程技巧</h2><h3 id="把代码分割成更小的单元块"><a href="#把代码分割成更小的单元块" class="headerlink" title="把代码分割成更小的单元块"></a>把代码分割成更小的单元块</h3><p>重构之后，我们将这部分逻辑抽象成一个函数，并且命名为 isLastDayOfMonth，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，大大提高了代码的可读性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.<span class="built_in">set</span>(Calendar.DATE, (calendar.<span class="built_in">get</span>(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.<span class="built_in">get</span>(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重构后的代码：提炼函数之后逻辑更加清晰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isLastDayOfMonth(<span class="keyword">new</span> Date())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLastDayOfMonth</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">  Calendar calendar = Calendar.getInstance();</span><br><span class="line">  calendar.setTime(date);</span><br><span class="line">  calendar.<span class="built_in">set</span>(Calendar.DATE, (calendar.<span class="built_in">get</span>(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (calendar.<span class="built_in">get</span>(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="避免函数参数过多"><a href="#避免函数参数过多" class="headerlink" title="避免函数参数过多"></a>避免函数参数过多</h3><p>函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候，我们就觉得参数有点过多了，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有 2 种处理方法。</p>
<ul>
<li>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。示例代码如下所示：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">(<span class="keyword">String</span> username, <span class="keyword">String</span> telephone, <span class="keyword">String</span> email)</span></span>;</span><br><span class="line"><span class="comment">// 拆分成多个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByUsername</span><span class="params">(<span class="keyword">String</span> username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByTelephone</span><span class="params">(<span class="keyword">String</span> telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUserByEmail</span><span class="params">(<span class="keyword">String</span> email)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>将函数的参数封装成对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postBlog</span><span class="params">(<span class="keyword">String</span> title, <span class="keyword">String</span> summary, <span class="keyword">String</span> keywords, <span class="keyword">String</span> content, <span class="keyword">String</span> category, <span class="keyword">long</span> authorId)</span></span>;</span><br><span class="line"><span class="comment">// 将参数封装成对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> title;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> summary;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> keywords;</span><br><span class="line">  <span class="keyword">private</span> Strint content;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">String</span> category;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> authorId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postBlog</span><span class="params">(Blog blog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面不太理解:<br><strong>除此之外，如果函数是对外暴露的远程接口，将参数封装成对象，还可以提高接口的兼容性。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。</strong></p>
<h3 id="勿用函数参数来控制逻辑"><a href="#勿用函数参数来控制逻辑" class="headerlink" title="勿用函数参数来控制逻辑"></a>勿用函数参数来控制逻辑</h3><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函数，可读性上也要更好。<br>不过，如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。示例代码如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId, <span class="keyword">boolean</span> isVip)</span></span>;</span><br><span class="line"><span class="comment">// 将其拆分成两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourseForVip</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成两个函数的调用方式</span></span><br><span class="line"><span class="keyword">boolean</span> isVip = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//...省略其他逻辑...</span></span><br><span class="line"><span class="keyword">if</span> (isVip) &#123;</span><br><span class="line">  buyCourseForVip(userId, courseId);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  buyCourse(userId, courseId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保留标识参数的调用方式更加简洁</span></span><br><span class="line"><span class="keyword">boolean</span> isVip = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//...省略其他逻辑...</span></span><br><span class="line">buyCourse(userId, courseId, isVip);</span><br></pre></td></tr></table></figure>

<p>除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为 null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。具体代码示例如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (startDate != null &amp;&amp; endDate != null) &#123;</span><br><span class="line">    <span class="comment">// 查询两个时间区间的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate != null &amp;&amp; endDate == null) &#123;</span><br><span class="line">    <span class="comment">// 查询startDate之后的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == null &amp;&amp; endDate != null) &#123;</span><br><span class="line">    <span class="comment">// 查询endDate之前的所有transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (startDate == null &amp;&amp; endDate == null) &#123;</span><br><span class="line">    <span class="comment">// 查询所有的transactions</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拆分成多个public函数，更加清晰、易用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsBetween</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, endDate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsStartWith</span><span class="params">(Long userId, Date startDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, startDate, null);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsEndWith</span><span class="params">(Long userId, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, null, endDate);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectAllTransactions</span><span class="params">(Long userId)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> selectTransactions(userId, null, null);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数设计要职责单一"><a href="#函数设计要职责单一" class="headerlink" title="函数设计要职责单一"></a>函数设计要职责单一</h3><p>能多单一就多单一</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExisting</span><span class="params">(<span class="keyword">String</span> telephone, <span class="keyword">String</span> username, <span class="keyword">String</span> email)</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(telephone)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByTelephone(telephone);</span><br><span class="line">    <span class="keyword">return</span> user != null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(username)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByUsername(username);</span><br><span class="line">    <span class="keyword">return</span> user != null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!StringUtils.isBlank(email)) &#123;</span><br><span class="line">    User user = userRepo.selectUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user != null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拆分成三个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByTelephone</span><span class="params">(<span class="keyword">String</span> telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByUsername</span><span class="params">(<span class="keyword">String</span> username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByEmail</span><span class="params">(<span class="keyword">String</span> email)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="移除过深的嵌套层次"><a href="#移除过深的嵌套层次" class="headerlink" title="移除过深的嵌套层次"></a>移除过深的嵌套层次</h3><p>解决嵌套过深的方法也比较成熟，有下面 4 种常见的思路。</p>
<ul>
<li>去掉多余的 if 或 else 语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">caculateTotalAmount</span><span class="params">(List&lt;Order&gt; orders)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orders == null || orders.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 此处的else可以去掉</span></span><br><span class="line">    <span class="keyword">double</span> amount = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Order order : orders) &#123;</span><br><span class="line">      <span class="keyword">if</span> (order != null) &#123;</span><br><span class="line">        amount += (order.getCount() * order.getPrice());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> amount;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">matchStrings</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; strList,<span class="keyword">String</span> substr)</span> </span>&#123;</span><br><span class="line">  List&lt;<span class="keyword">String</span>&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != null &amp;&amp; substr != null) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str != null) &#123; <span class="comment">// 跟下面的if语句可以合并在一起</span></span><br><span class="line">        <span class="keyword">if</span> (str.contains(substr)) &#123;</span><br><span class="line">          matchedStrings.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用编程语言提供的 continue、break、return 关键字，提前退出嵌套。代码示例如下所示：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">matchStrings</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; strList,<span class="keyword">String</span> substr)</span> </span>&#123;</span><br><span class="line">  List&lt;<span class="keyword">String</span>&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != null &amp;&amp; substr != null)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str != null &amp;&amp; str.contains(substr)) &#123;</span><br><span class="line">        matchedStrings.add(str);</span><br><span class="line">        <span class="comment">// 此处还有10行代码...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重构后的代码：使用continue提前退出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">matchStrings</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; strList,<span class="keyword">String</span> substr)</span> </span>&#123;</span><br><span class="line">  List&lt;<span class="keyword">String</span>&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != null &amp;&amp; substr != null)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str == null || !str.contains(substr)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      matchedStrings.add(str);</span><br><span class="line">      <span class="comment">// 此处还有10行代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调整执行顺序来减少嵌套。具体的代码示例如下所示</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">matchStrings</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; strList,<span class="keyword">String</span> substr)</span> </span>&#123;</span><br><span class="line">  List&lt;<span class="keyword">String</span>&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (strList != null &amp;&amp; substr != null) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">String</span> str : strList) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str != null) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.contains(substr)) &#123;</span><br><span class="line">          matchedStrings.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重构后的代码：先执行判空逻辑，再执行正常逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">matchStrings</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; strList,<span class="keyword">String</span> substr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (strList == null || substr == null) &#123; <span class="comment">//先判空</span></span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;<span class="keyword">String</span>&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">String</span> str : strList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != null) &#123;</span><br><span class="line">      <span class="keyword">if</span> (str.contains(substr)) &#123;</span><br><span class="line">        matchedStrings.add(str);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将部分嵌套逻辑封装成函数调用，以此来减少嵌套。具体的代码示例如下所示</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">appendSalts</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; passwords)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (passwords == null || passwords.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List&lt;<span class="keyword">String</span>&gt; passwordsWithSalt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">String</span> password : passwords) &#123;</span><br><span class="line">    <span class="keyword">if</span> (password == null) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (password.length() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> passwordsWithSalt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重构后的代码：将部分逻辑抽成函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;<span class="keyword">String</span>&gt; <span class="title">appendSalts</span><span class="params">(List&lt;<span class="keyword">String</span>&gt; passwords)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (passwords == null || passwords.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;<span class="keyword">String</span>&gt; passwordsWithSalt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">String</span> password : passwords) &#123;</span><br><span class="line">    <span class="keyword">if</span> (password == null) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    passwordsWithSalt.add(appendSalt(password));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> passwordsWithSalt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">String</span> <span class="title">appendSalt</span><span class="params">(<span class="keyword">String</span> password)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">String</span> passwordWithSalt = password;</span><br><span class="line">  <span class="keyword">if</span> (password.length() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> passwordWithSalt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，常用的还有通过使用多态来替代 if-else、switch-case 条件判断的方法。这个思路涉及代码结构的改动，我们会在后面的章节中讲到</p>
<h3 id="学会使用解释性变量"><a href="#学会使用解释性变量" class="headerlink" title="学会使用解释性变量"></a>学会使用解释性变量</h3><p>常用的用解释性变量来提高代码的可读性的情况有下面 2 种。</p>
<ul>
<li>常量取代魔法数字</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 常量替代魔法数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Double PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用解释性变量来解释复杂表达式。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 引入解释性变量后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">boolean</span> isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</span><br><span class="line"><span class="keyword">if</span> (isSummer) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>关于编码技巧<br>将复杂的逻辑提炼拆分成函数和类。<br>通过拆分成多个函数或将参数封装为对象的方式，来处理参数过多的情况。<br>函数中不要使用参数来做代码执行逻辑的控制。<br>函数设计要职责单一。<br>移除过深的嵌套层次，方法包括：去掉多余的 if 或 else 语句，使用 continue、break、return 关键字提前退出嵌套，调整执行顺序来减少嵌套，将部分嵌套逻辑抽象成函数。<br>用字面常量取代魔法数。<br>用解释性变量来解释复杂表达式，以此提高代码可读性。</li>
</ul>
]]></content>
      <categories>
        <category>coding</category>
        <category>c++</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>c++</tag>
      </tags>
  </entry>
</search>
